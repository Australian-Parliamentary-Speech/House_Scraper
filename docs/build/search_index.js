var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"#API","category":"page"},{"location":"api/","page":"API","title":"API","text":"##ParlinfoSpeechScraper","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ParlinfoSpeechScraper","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [ParlinfoSpeechScraper]","category":"page"},{"location":"api/#ParlinfoSpeechScraper.get_args-Tuple{}","page":"API","title":"ParlinfoSpeechScraper.get_args","text":"get_args()\n\nParse command-line arguments\n\nThis function sets up and parses command-line arguments using the ArgParse package. It defines the arguments that can be passed to the script, including options for verbosity and input file path.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.main-Tuple{Any, Any}","page":"API","title":"ParlinfoSpeechScraper.main","text":"main(toml_path, verbose)\n\nMain function to initialize and execute the Parlinfo Speech Scraper\n\nThis function initializes the input configuration from a TOML file specified by toml_path with optional verbosity controlled by verbose. It then runs the ParlinfoSpeechScraper using the configuration.\n\nInputs:\n\ntoml_path: Path to the TOML configuration file.\nverbose: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.main-Tuple{}","page":"API","title":"ParlinfoSpeechScraper.main","text":"main()\n\nMain function to process command-line arguments and run the program\n\nThis function serves as the entry point of the script. It processes command-line arguments, retrieves the necessary parameters, and calls the main processing function with those parameters.\n\nInputs: None\n\nArguments:\n\nargs: A dictionary containing the parsed command-line arguments.\nargs[\"input\"]: Path to the input TOML file.\nargs[\"verbose\"]: Boolean flag indicating if logging verbosity should be increased.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"##RunModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ParlinfoSpeechScraper.RunModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [RunModule]","category":"page"},{"location":"api/#ParlinfoSpeechScraper.RunModule.get_date-Tuple{Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.get_date","text":"get_date(fn)\n\nGet the date from the xml file\n\nInputs:\n\nfn: the file directory for the xml file\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.recurse","page":"API","title":"ParlinfoSpeechScraper.RunModule.recurse","text":"recurse(soup, date, PhaseType, xmlnode, io, index=1, depth=0, maxdepth=0, node_tree=Vector{Node}())\n\nRecursively process XML nodes and write data to output\n\nThis function recursively processes XML nodes, extracts relevant data, and writes it to an output stream. It handles node types, depth limitations, and maintains a tree of processed nodes.\n\nInputs:\n\nsoup: The parsed XML document.\ndate: The date associated with the XML document.\nPhaseType: The phase type determined from the date.\nxml_node: The current XML node being processed.\nio: The output stream where data is written.\nindex (optional): The index of the current node (default is 1).\ndepth (optional): The current depth of recursion (default is 0).\nmax_depth (optional): The maximum depth for recursion (default is 0, meaning no limit).\nnode_tree (optional): A vector maintaining the tree of nodes (default is an empty vector).\n\n\n\n\n\n","category":"function"},{"location":"api/#ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper-Tuple{Dict{String, Any}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.run_ParlinfoSpeechScraper","text":"run_ParlinfoSpeechScraper(toml::Dict{String, Any})\n\nThis function processes XML files for parliamentary speeches according to the configuration specified in the provided TOML dictionary. It reads XML file paths, processes each XML file, and outputs the results to a specified directory.\n\nInputs:\n\ntoml: A dictionary containing configuration options for the scraper.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.run_xml-NTuple{4, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.run_xml","text":"run_xml(fn, output_path, csv_exist, edit_opt)\n\nProcess and save XML data to CSV\n\nThis function processes an XML file, extracts relevant data, and saves it to a CSV file. If specified, it also edits the CSV file after creation.\n\nInputs:\n\nfn: The file path for the XML file.\noutput_path: The directory where the processed CSV file will be saved.\ncsv_exist: Boolean flag indicating if a CSV file already exists.\nedit_opt: Boolean flag indicating if the CSV file should be edited after creation.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"##NodeModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ParlinfoSpeechScraper.RunModule.NodeModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NodeModule]","category":"page"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","text":"Abstract type that represent the xml nodes\n\n\n\n\n\n","category":"type"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.AbstractPhase","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.AbstractPhase","text":"Abstract type that represent the different phases in processing the xml files\n\n\n\n\n\n","category":"type"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.GenericNode","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.GenericNode","text":"Default node type\n\n\n\n\n\n","category":"type"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.GenericPhase","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.GenericPhase","text":"Default phase: 2023\n\n\n\n\n\n","category":"type"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.Node","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.Node","text":"Node\n\nA struct that represents a node in the xml file\n\nnode: EzXML node index: the index of the node on its own branch date: a floating number representation for the date soup: EzXML root node\n\n\n\n\n\n","category":"type"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.construct_row-NTuple{5, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.construct_row","text":"constructrow(node, nodetree, flags, talker_contents, content)\n\nInputs:\n\nnode: A Node struct.\nnode_tree: A vector representing a tree of nodes for context.\nflags: An array of flags indicating characteristics of node.\ntalker_contents: Contents related to speakers or talkers associated with node.\ncontent: Raw content associated with node.\n\nReturns:\n\nAn array (row) representing the data to be written to a CSV file. The row includes:\nFlags indicating characteristics of node.\nTalker contents related to speakers or talkers.\nCleaned text content derived from content.\nSection title for SubdebateNode, if found.\nSection title for DebateNode, if found.\nXPath path of node within the XML document.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.define_flags-Tuple{Node, Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.define_flags","text":"defineflags(node::Node{<:AbstractNode{<:AbstractPhase}}, nodetree)\n\nGenerates flags based on the characteristics of the given node.\n\nInputs:\n\nnode: A Node struct.\nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn array of flags indicating characteristics of node\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type-NTuple{5, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_node_type","text":"detectnodetype(node, node_tree, date, soup, PhaseType)\n\nInputs:\n\nnode: The XML node to determine the type for.\nnode_tree: A vector representing a tree of nodes\ndate: The date associated with the node.\nsoup: The root node.\nPhaseType: The phase type determined from the date of XML.\n\nReturns:\n\nThe detected node type (NodeType).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase-Tuple{Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.detect_phase","text":"detect_phase(date)\n\nInputs:\n\ndate: A floating-point number representing the date to detect the phase for.\n\nReturns:\n\nThe phase associated with the provided date, or AbstractPhase if no specific phase is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber-Tuple{Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_chamber","text":"findchamber(node, nodetree)\n\nIdentifies the type of chamber associated with the given XML node.\n\nInputs:\n\nnode: The XML node \nnode_tree: A vector representing a tree of nodes for context.\n\nReturns:\n\nAn integer indicating the chamber type:\n2 for a federal chamber (FedChamberNode).\n1 for a chamber (ChamberNode).\n0 if no chamber node is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title-NTuple{4, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_section_title","text":"findsectiontitle(node, nodetree, soup, sectiontype)\n\nInputs:\n\nnode: The XML node from which to extract the section title.\nnode_tree: A vector representing a tree of nodes for context.\nsoup: The root node of the XML document.\nsection_type: The nodenames of the types of section nodes where the title is wanted. For example, \"speech\".\n\nReturns:\n\nThe title of the specified section_type found within the XML document, or \"N/A\" if not found.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p-Tuple{Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.find_talker_in_p","text":"findtalkerinp(pnode)\n\nFinds talker information inside the current node\n\nInputs:\n\np_node: the p_node\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_all_subtypes","text":"get_all_subtypes(type, st=[])\n\nGet every subtype of the provided type parameter.\n\nInputs:\n\ntype: the provided type\n\n\n\n\n\n","category":"function"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.get_sections-Tuple{Type{<:PNode}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_sections","text":"get_sections(::Type{<:PNode})\n\nGet the sections where PNodes are scraped\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Tuple{Type{<:PNode}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:PNode})\n\nGet the allowed nodenames for specific types\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths-Union{Tuple{Type{<:N}}, Tuple{N}} where N<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.get_xpaths","text":"get_xpaths(::Type{<:N}) where {N <: AbstractNode}\n\nThis function serves as a placeholder and returns an empty array, which is meant to provide the nodenames allowed for each type. For example, speech nodes can have names \"speech\" or \"continue\". \n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type-Tuple{Node{<:PNode}, Any, Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_first_node_type","text":"isfirstnodetype(node::Node{<:PNode}, parentnode, allowednames, nodetree)\n\nChecks if the given node is the first occurrence of its type under parent_node..\n\nInputs:\n\nnode: the current node\nparent_node: The parent node of the node\nallowed_names: An array of allowed names (XPaths) associated with the type of node.\nnode_tree: A vector representing a tree of nodes for context.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:PNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:PNode}, phase::Type{<:AbstractPhase}, soup, args...; kwargs...)\n\nChecks if an xml node is PNode.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype-Tuple{Any, Any, Type{<:ParlinfoSpeechScraper.RunModule.NodeModule.AbstractNode}, Type{<:AbstractPhase}, Any, Vararg{Any}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.is_nodetype","text":"isnodetype(node, nodetree, nodetype::Type{<:AbstractNode}, phase::Type{<:AbstractPhase}, soup, args...; kwargs...)\n\nInputs:\n\nnode: The XML node to evaluate.\nnode_tree: A vector representing a tree of nodes for context.\nnodetype: A subtype of AbstractNode representing the type of node to check against.\nphase: A subtype of AbstractPhase representing the phase associated with the node.\nsoup: The root node.\nargs...: Optional additional arguments.\nkwargs...: Optional keyword arguments.\n\nReturns:\n\ntrue if the name of node is found in the allowed names associated with nodetype for the given phase, false otherwise.\n\nNotes: More specific detection method for nodes is defined in nodes/\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent-Tuple{Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.p_with_a_as_parent","text":"Pwithaasparent(p_node)\n\nFinds talker information inside the parent p_node\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.parse_node-Tuple{Node, Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.parse_node","text":"parsenode(node::Node, nodetree, io)\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\nio: The output stream where processed data is written.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node, nodetree)\n\nThis function serves as a placeholder or default behavior.\n\nInputs:\n\nnode: xml node of Node struct\nnode_tree: A vector representing a tree of nodes for context.\n\nNotes:\n\nThis function is typically invoked when no specific processing behavior is defined for the NodeType associated with node.\nUsers may customize or define specific behaviors for different NodeType instances within their implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.process_node-Tuple{Node{<:PNode}, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.process_node","text":"processnode(node::Node{<:PNode}, nodetree)\n\nIt processes node of PNode type. Usually the most scraped node type.\n\nInputs:\n\nnode: of struct Node with the parameter PNode\nnode_tree: A vector representing a tree of nodes for context.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name-Tuple{Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_name","text":"reversefindfirstnodename(node_tree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names to search for.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name-Tuple{Any, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.NodeModule.reverse_find_first_node_not_name","text":"reversefindfirstnodenotname(nodetree, names)\n\nInputs:\n\nnode_tree: A vector representing a tree of nodes to search in reverse order.\nnames: A collection of node names. The function searches for the first node from node_tree in reverse order whose name is not in this collection.\n\nReturns:\n\nThe first node from node_tree in reverse order whose name is not in the names collection, or nothing if no such node is found.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"##XMLModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = ParlinfoSpeechScraper.RunModule.EditModule","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [EditModule]","category":"page"},{"location":"api/#ParlinfoSpeechScraper.RunModule.EditModule.edit_csv-Tuple{Any, Type{<:AbstractPhase}}","page":"API","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_csv","text":"edit_csv(fn, ::Type{<:AbstractPhase})\n\nTwo steps are implemented here. The first step does mostly regular expression processing. The second step collapses some of the N/As to the previous talker.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up-Tuple{Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.EditModule.edit_set_up","text":"editsetup(headers)\n\nSets up a dictionary mapping each element in headers to its corresponding index.\n\nInputs:\n\nheaders: An array of header names or keys.\n\nReturns:\n\nA dictionary where each header in headers is mapped to its index position.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches-NTuple{4, Any}","page":"API","title":"ParlinfoSpeechScraper.RunModule.EditModule.find_all_child_speeches","text":"function findallchildspeeches(rowno,rows,headertonum,is_written)\n\nFind all the speeches that belong to a single talker \n\n\n\n\n\n","category":"method"},{"location":"#ParlinfoSpeechScraper-Documentation","page":"ParlinfoSpeechScraper","title":"ParlinfoSpeechScraper Documentation","text":"","category":"section"}]
}
